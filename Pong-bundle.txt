=== FILE: Makefile ===
GBDK_HOME ?= /opt/gbdk
LCC := $(GBDK_HOME)/bin/lcc

TARGET := pong
BUILD := build
SRC := src

CFLAGS := -Wl-yt0x1B -Wl-ya4 -Wm-yoA -Wm-ys0

$(BUILD)/$(TARGET).gb: $(SRC)/pong.c | $(BUILD)
	$(LCC) $(CFLAGS) -o $@ $<

$(BUILD):
	mkdir -p $(BUILD)

clean:
	rm -rf $(BUILD)


=== FILE: .github/workflows/build.yml ===
name: Build Game Boy ROM

on:
  push:
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install build tools
        run: |
          sudo apt-get update
          sudo apt-get install -y unzip make wget

      - name: Download GBDK-2020
        run: |
          GBDK_VERSION=4.2.0
          wget -q https://github.com/gbdk-2020/gbdk-2020/releases/download/${GBDK_VERSION}/gbdk-linux64-${GBDK_VERSION}.tar.gz
          tar -xzf gbdk-linux64-${GBDK_VERSION}.tar.gz
          echo "GBDK_HOME=$PWD/gbdk" >> $GITHUB_ENV

      - name: Build ROM
        run: |
          make GBDK_HOME=${{ env.GBDK_HOME }}

      - name: Upload ROM artifact
        uses: actions/upload-artifact@v4
        with:
          name: pong-rom
          path: build/pong.gb


=== FILE: src/pong.c ===
/*
   Game Boy Pong (GBDK-2020)
   Features:
     - Title menu with Difficulty selection (Easy / Normal / Hard)
     - 1P vs CPU
     - Score to 11
     - Pause (START), Game Over screen (A = replay, SELECT = menu)
     - Simple sound effects
*/

#include <gb/gb.h>
#include <gb/cgb.h>
#include <gb/font.h>
#include <stdio.h>
#include <stdlib.h>

typedef enum { ST_MENU=0, ST_PLAY, ST_PAUSE, ST_GAMEOVER } GameState;
typedef enum { DF_EASY=0, DF_NORMAL=1, DF_HARD=2 } Difficulty;

#define SCREEN_W 160u
#define SCREEN_H 144u

#define PADDLE_W   2u
#define PADDLE_H_E 24u
#define PADDLE_H_N 20u
#define PADDLE_H_H 16u

#define PADDLE_SPEED 2
#define BALL_SIZE 4u

#define TOP_LIMIT 16u
#define BOT_LIMIT 144u-8u

GameState g_state;
Difficulty g_diff;

UINT8 p1_y, cpu_y;
UINT8 p_h;
INT16 ball_x, ball_y;
INT8  ball_vx, ball_vy;
UINT8 ball_speed;

UINT8 score_p1, score_cpu;
UINT8 menu_idx;

UINT8 frames;

void draw_hud(void);
void draw_court(void);
void reset_round(UINT8 last_scored_left);
void start_game(void);
void menu_screen(void);
void game_over_screen(void);
void sfx_beep(void);
void sfx_score(void);

void clear_screen() {
    HIDE_SPRITES; HIDE_WIN; HIDE_BKG;
    printf("\x1b[2J");
}

void draw_center_net() {
    for (UINT8 y = TOP_LIMIT/8; y < 18; ++y) {
        if (y % 2 == 0) {
            gotoxy(9, y);
            putchar('|');
        }
    }
}

void draw_paddle(INT16 x, INT16 y, UINT8 h) {
    UINT8 top_row = (UINT8)(y / 8u);
    UINT8 bottom_row = (UINT8)((y + h) / 8u);
    UINT8 column = (UINT8)(x / 8u);
    for (UINT8 r = top_row; r <= bottom_row && r < 18; ++r) {
        gotoxy(column, r);
        putchar(0xdb);
    }
}

void erase_paddle(INT16 x, INT16 y, UINT8 h) {
    UINT8 top_row = (UINT8)(y / 8u);
    UINT8 bottom_row = (UINT8)((y + h) / 8u);
    UINT8 column = (UINT8)(x / 8u);
    for (UINT8 r = top_row; r <= bottom_row && r < 18; ++r) {
        gotoxy(column, r);
        putchar(' ');
    }
}

void draw_ball(INT16 x, INT16 y) {
    gotoxy((UINT8)(x/8u), (UINT8)(y/8u));
    putchar('o');
}

void erase_ball(INT16 x, INT16 y) {
    gotoxy((UINT8)(x/8u), (UINT8)(y/8u));
    putchar(' ');
}

void clamp_paddles() {
    if (p1_y < TOP_LIMIT) p1_y = TOP_LIMIT;
    if ((UINT16)p1_y + p_h > BOT_LIMIT) p1_y = BOT_LIMIT - p_h;
    if (cpu_y < TOP_LIMIT) cpu_y = TOP_LIMIT;
    if ((UINT16)cpu_y + p_h > BOT_LIMIT) cpu_y = BOT_LIMIT - p_h;
}

void sfx_beep() {
    NR10_REG = 0x00U;
    NR11_REG = 0x80U;
    NR12_REG = 0xf3U;
    NR13_REG = 0x40U;
    NR14_REG = 0x87U;
}

void sfx_score() {
    NR10_REG = 0x16U;
    NR11_REG = 0x40U;
    NR12_REG = 0xf2U;
    NR13_REG = 0x73U;
    NR14_REG = 0x87U;
}

void draw_hud() {
    gotoxy(0,0);
    printf("P1:%2u", score_p1);
    gotoxy(13,0);
    printf("CPU:%2u", score_cpu);
    gotoxy(5,0);
    switch(g_diff) {
        case DF_EASY:   printf(" E "); break;
        case DF_NORMAL: printf(" N "); break;
        case DF_HARD:   printf(" H "); break;
    }
}

void draw_court() {
    clear_screen();
    draw_hud();
    draw_center_net();
}

void reset_round(UINT8 last_scored_left) {
    p1_y = 72u - p_h/2;
    cpu_y = p1_y;
    ball_x = 80; ball_y = 72;
    ball_vx = (last_scored_left ? -1 : 1) * (INT8)ball_speed;
    ball_vy = (rand() % 2 ? 1 : -1) * (INT8)(ball_speed - 1);
}

void start_game() {
    score_p1 = score_cpu = 0;
    frames = 0;
    draw_court();
    reset_round(0);
}

void ai_update() {
    UINT8 ai_speed;
    switch(g_diff) {
        case DF_EASY: ai_speed = 1; break;
        case DF_NORMAL: ai_speed = 2; break;
        default: ai_speed = 3; break;
    }
    if ((frames % 2) == 0) {
        INT16 target = ball_y - (p_h/2);
        if (cpu_y + p_h/2 < target) cpu_y += ai_speed;
        else if (cpu_y + p_h/2 > target) cpu_y -= ai_speed;
    }
    clamp_paddles();
}

void menu_screen() {
    clear_screen();
    gotoxy(1,3);  printf("GAME BOY  PONG");
    gotoxy(1,5);  printf("Select Difficulty:");
    for (UINT8 i=0;i<3;i++){
        gotoxy(2,7+i);
        putchar(i==menu_idx?'>':' ');
        switch(i){
            case 0: printf(" Easy"); break;
            case 1: printf(" Normal"); break;
            case 2: printf(" Hard"); break;
        }
    }
    gotoxy(1,11); printf("A: Start   SELECT: Reset Hi");
    gotoxy(1,13); printf("Controls: Up/Down to move");
    gotoxy(1,15); printf("START: Pause");
}

void game_over_screen() {
    clear_screen();
    gotoxy(4,6);
    if (score_p1 > score_cpu) printf("YOU WIN! %u-%u", score_p1, score_cpu);
    else printf("YOU LOSE! %u-%u", score_p1, score_cpu);
    gotoxy(2,9);  printf("A: Play Again    SELECT: Menu");
}

void update_difficulty() {
    switch(g_diff) {
        case DF_EASY:   ball_speed = 2; p_h = PADDLE_H_E; break;
        case DF_NORMAL: ball_speed = 3; p_h = PADDLE_H_N; break;
        case DF_HARD:   ball_speed = 4; p_h = PADDLE_H_H; break;
    }
}

void main(void) {
    font_t min_font;
    DISPLAY_OFF;
    font_init();
    min_font = font_load(font_min);
    font_set(min_font);

    NR52_REG = 0x80U;
    NR50_REG = 0x77U;
    NR51_REG = 0xFFU;

    SHOW_BKG; DISPLAY_ON;

    g_state = ST_MENU;
    g_diff = DF_NORMAL;
    menu_idx = 1;
    menu_screen();

    while(1) {
        switch(g_state) {
            case ST_MENU: {
                UINT8 j = joypad();
                if (j & J_UP)   { if (menu_idx>0){ menu_idx--; menu_screen(); delay(120);} }
                if (j & J_DOWN) { if (menu_idx<2){ menu_idx++; menu_screen(); delay(120);} }
                if (j & J_A) {
                    g_diff = (Difficulty)menu_idx;
                    update_difficulty();
                    start_game();
                    g_state = ST_PLAY;
                    delay(120);
                }
                if (j & J_SELECT) { sfx_beep(); delay(120); }
            } break;

            case ST_PLAY: {
                UINT8 j = joypad();
                if (j & J_UP)   p1_y -= PADDLE_SPEED;
                if (j & J_DOWN) p1_y += PADDLE_SPEED;
                if (j & J_START){ g_state = ST_PAUSE; gotoxy(5,1); printf("PAUSED"); delay(180); }
                clamp_paddles();

                erase_ball(ball_x, ball_y);
                erase_paddle(8, p1_y, p_h);
                erase_paddle(152, cpu_y, p_h);

                ball_x += ball_vx;
                ball_y += ball_vy;

                if ((UINT8)ball_y <= TOP_LIMIT+4) { ball_y = TOP_LIMIT+4; ball_vy = -ball_vy; sfx_beep(); }
                if ((UINT8)ball_y >= BOT_LIMIT-4) { ball_y = BOT_LIMIT-4; ball_vy = -ball_vy; sfx_beep(); }

                if (ball_x <= 16 && ball_x >= 8) {
                    if ((UINT8)ball_y >= p1_y && (UINT8)ball_y <= p1_y + p_h) {
                        ball_vx = (INT8)(+ball_speed);
                        INT8 rel = (INT8)(ball_y - (p1_y + p_h/2));
                        ball_vy = (rel / 8);
                        sfx_beep();
                    }
                }
                if (ball_x >= 144 && ball_x <= 152) {
                    if ((UINT8)ball_y >= cpu_y && (UINT8)ball_y <= cpu_y + p_h) {
                        ball_vx = (INT8)(-ball_speed);
                        INT8 rel = (INT8)(ball_y - (cpu_y + p_h/2));
                        ball_vy = (rel / 8);
                        sfx_beep();
                    }
                }

                if (ball_x < 0) {
                    score_cpu++;
                    draw_hud();
                    sfx_score();
                    if (score_cpu >= 11) { g_state = ST_GAMEOVER; delay(300); game_over_screen(); }
                    else reset_round(0);
                } else if (ball_x > SCREEN_W) {
                    score_p1++;
                    draw_hud();
                    sfx_score();
                    if (score_p1 >= 11) { g_state = ST_GAMEOVER; delay(300); game_over_screen(); }
                    else reset_round(1);
                }

                ai_update();

                draw_center_net();
                draw_paddle(8, p1_y, p_h);
                draw_paddle(152, cpu_y, p_h);
                draw_ball(ball_x, ball_y);

                frames++;
                wait_vbl_done();
            } break;

            case ST_PAUSE: {
                UINT8 j = joypad();
                if (j & J_START) {
                    gotoxy(5,1); printf("     ");
                    g_state = ST_PLAY; delay(180);
                }
                wait_vbl_done();
            } break;

            case ST_GAMEOVER: {
                UINT8 j = joypad();
                if (j & J_A) {
                    start_game();
                    g_state = ST_PLAY;
                    delay(180);
                } else if (j & J_SELECT) {
                    menu_screen();
                    g_state = ST_MENU;
                    delay(180);
                }
                wait_vbl_done();
            } break;
        }
    }
}
